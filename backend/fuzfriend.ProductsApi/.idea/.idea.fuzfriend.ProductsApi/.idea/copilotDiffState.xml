<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/fuzfriend.ProductsApi.Tests/fuzfriend.ProductsApi.Tests.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fuzfriend.ProductsApi.Tests/fuzfriend.ProductsApi.Tests.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;&#10;    &lt;IsPackable&gt;false&lt;/IsPackable&gt;&#10;    &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;  &lt;/PropertyGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.InMemory&quot; Version=&quot;9.0.10&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;18.0.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.7.1&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.5.8&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.2&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Bogus&quot; Version=&quot;35.6.4&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;ProjectReference Include=&quot;../fuzfriend.ProductsApi/fuzfriend.ProductsApi.csproj&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;&#10;    &lt;IsPackable&gt;false&lt;/IsPackable&gt;&#10;    &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;  &lt;/PropertyGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.InMemory&quot; Version=&quot;9.0.10&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;18.0.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.7.1&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.5.8&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.2&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Bogus&quot; Version=&quot;35.6.4&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Mvc.Testing&quot; Version=&quot;9.0.8&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;ProjectReference Include=&quot;../fuzfriend.ProductsApi/fuzfriend.ProductsApi.csproj&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/fuzfriend.ProductsApi/Controllers/ProductsController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fuzfriend.ProductsApi/Controllers/ProductsController.cs" />
              <option name="originalContent" value="using fuzfriend.ProductsApi.DTOs;&#10;using fuzfriend.ProductsApi.Services;&#10;using Microsoft.AspNetCore.Mvc;&#10;&#10;namespace fuzfriend.ProductsApi.Controllers;&#10;&#10;[ApiController]&#10;[Route(&quot;api/[controller]&quot;)]&#10;public class ProductsController : ControllerBase&#10;{&#10;    private readonly ProductService _service;&#10;&#10;    public ProductsController(ProductService service)&#10;    {&#10;        _service = service;&#10;    }&#10;&#10;    [HttpPost(&quot;search&quot;)]&#10;    public async Task&lt;ActionResult&lt;ProductResponse&gt;&gt; SearchProducts([FromBody] ProductQueryDto query)&#10;    {&#10;        var result = await _service.GetProductsAsync(query);&#10;        return Ok(result);&#10;    }&#10;}" />
              <option name="updatedContent" value="using fuzfriend.ProductsApi.DTOs;&#10;using fuzfriend.ProductsApi.Services;&#10;using Microsoft.AspNetCore.Mvc;&#10;&#10;namespace fuzfriend.ProductsApi.Controllers;&#10;&#10;[ApiController]&#10;[Route(&quot;api/[controller]&quot;)]&#10;public class ProductsController : ControllerBase&#10;{&#10;    private readonly ProductService _service;&#10;&#10;    public ProductsController(ProductService service)&#10;    {&#10;        _service = service;&#10;    }&#10;&#10;    [HttpGet]&#10;    public async Task&lt;ActionResult&lt;ProductResponse&gt;&gt; GetProducts([FromQuery] int page = 1, [FromQuery] int pageSize = 20)&#10;    {&#10;        var result = await _service.GetProductsAsync(new ProductQueryDto { Page = page, PageSize = pageSize });&#10;        return Ok(result);&#10;    }&#10;&#10;    [HttpGet(&quot;count&quot;)]&#10;    public async Task&lt;ActionResult&lt;int&gt;&gt; GetProductsCount()&#10;    {&#10;        var result = await _service.GetProductsAsync(new ProductQueryDto { Page = 1, PageSize = 1 });&#10;        return Ok(result.TotalCount);&#10;    }&#10;&#10;    [HttpPost(&quot;search&quot;)]&#10;    public async Task&lt;ActionResult&lt;ProductResponse&gt;&gt; SearchProducts([FromBody] ProductQueryDto? query)&#10;    {&#10;        var result = await _service.GetProductsAsync(query);&#10;        return Ok(result);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/fuzfriend.ProductsApi/DTOs/ProductQueryDto.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fuzfriend.ProductsApi/DTOs/ProductQueryDto.cs" />
              <option name="originalContent" value="using fuzfriend.ProductsApi.Models;&#10;&#10;namespace fuzfriend.ProductsApi.DTOs;&#10;&#10;public class ProductQueryDto&#10;{&#10;    public string? Category { get; set; }&#10;    public List&lt;string&gt;? Brands { get; set; }&#10;    public List&lt;string&gt;? Colours { get; set; }&#10;    public List&lt;string&gt;? Sizes { get; set; }&#10;    public decimal? MinPrice { get; set; }&#10;    public decimal? MaxPrice { get; set; }&#10;    public double? MinRating { get; set; }&#10;    public bool? OnPromotion { get; set; }&#10;    public int Page { get; set; } = 1;&#10;    public int PageSize { get; set; } = 20;&#10;}&#10;&#10;public class FilterOptions&#10;{&#10;    public List&lt;string&gt; Categories { get; set; } = new();&#10;    public List&lt;string&gt; Brands { get; set; } = new();&#10;    public List&lt;string&gt; Colours { get; set; } = new();&#10;    public List&lt;string&gt; Sizes { get; set; } = new();&#10;    public decimal MinPrice { get; set; }&#10;    public decimal MaxPrice { get; set; }&#10;    public List&lt;int&gt; Ratings { get; set; } = new();&#10;    public bool HasPromotions { get; set; }&#10;}&#10;&#10;public class ProductResponse&#10;{&#10;    public IEnumerable&lt;Product&gt; Products { get; set; } = Enumerable.Empty&lt;Product&gt;();&#10;    public FilterOptions Filters { get; set; } = new();&#10;    public int TotalCount { get; set; }&#10;}" />
              <option name="updatedContent" value="using fuzfriend.ProductsApi.Models;&#10;&#10;namespace fuzfriend.ProductsApi.DTOs;&#10;&#10;public class ProductQueryDto&#10;{&#10;    // Single category for backward compatibility&#10;    public string? Category { get; set; }&#10;    // New: support multiple categories&#10;    public List&lt;string&gt;? Categories { get; set; }&#10;    public List&lt;string&gt;? Brands { get; set; }&#10;    public List&lt;string&gt;? Colours { get; set; }&#10;    public List&lt;string&gt;? Sizes { get; set; }&#10;    public decimal? MinPrice { get; set; }&#10;    public decimal? MaxPrice { get; set; }&#10;    public double? MinRating { get; set; }&#10;    public bool? OnPromotion { get; set; }&#10;    public int Page { get; set; } = 1;&#10;    public int PageSize { get; set; } = 20;&#10;&#10;    // New: sorting options (supported: title, price, rating, brand, category)&#10;    public string? SortBy { get; set; }&#10;    // asc or desc&#10;    public string? SortDirection { get; set; }&#10;}&#10;&#10;public class FilterOptions&#10;{&#10;    public List&lt;string&gt; Categories { get; set; } = new();&#10;    public List&lt;string&gt; Brands { get; set; } = new();&#10;    public List&lt;string&gt; Colours { get; set; } = new();&#10;    public List&lt;string&gt; Sizes { get; set; } = new();&#10;    public decimal MinPrice { get; set; }&#10;    public decimal MaxPrice { get; set; }&#10;    public List&lt;int&gt; Ratings { get; set; } = new();&#10;    public bool HasPromotions { get; set; }&#10;}&#10;&#10;public class ProductResponse&#10;{&#10;    public IEnumerable&lt;Product&gt; Products { get; set; } = Enumerable.Empty&lt;Product&gt;();&#10;    public FilterOptions Filters { get; set; } = new();&#10;    public int TotalCount { get; set; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/fuzfriend.ProductsApi/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fuzfriend.ProductsApi/Program.cs" />
              <option name="originalContent" value="using fuzfriend.ProductsApi.Data;&#10;using fuzfriend.ProductsApi.Services;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Add services to the container.&#10;&#10;builder.Services.AddControllers();&#10;// Learn more about configuring OpenAPI at https://aka.ms/aspnet/openapi&#10;builder.Services.AddSwaggerGen();&#10;&#10;builder.Services.AddControllers();&#10;builder.Services.AddEndpointsApiExplorer();&#10;&#10;&#10;// PostgreSQL connection&#10;builder.Services.AddDbContext&lt;EcommerceDbContext&gt;(options =&gt;&#10;    options.UseNpgsql(builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));&#10;&#10;// Register services&#10;builder.Services.AddScoped&lt;ProductService&gt;();&#10;&#10;var app = builder.Build();&#10;&#10;// Configure the HTTP request pipeline.&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.MapOpenApi();&#10;}&#10;&#10;app.UseSwagger();&#10;app.UseSwaggerUI();&#10;app.UseHttpsRedirection();&#10;app.MapControllers();&#10;&#10;using (var scope = app.Services.CreateScope())&#10;{&#10;    var db = scope.ServiceProvider.GetRequiredService&lt;EcommerceDbContext&gt;();&#10;    db.Database.Migrate();&#10;    DbSeeder.Seed(db);&#10;}&#10;&#10;app.Run();&#10;&#10;" />
              <option name="updatedContent" value="using fuzfriend.ProductsApi.Data;&#10;using fuzfriend.ProductsApi.Services;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Add services to the container.&#10;&#10;builder.Services.AddControllers();&#10;// Learn more about configuring OpenAPI at https://aka.ms/aspnet/openapi&#10;builder.Services.AddSwaggerGen();&#10;&#10;builder.Services.AddControllers();&#10;builder.Services.AddEndpointsApiExplorer();&#10;&#10;// Database connection: Use InMemory for Testing, PostgreSQL otherwise&#10;if (builder.Environment.IsEnvironment(&quot;Testing&quot;))&#10;{&#10;    builder.Services.AddDbContext&lt;EcommerceDbContext&gt;(options =&gt;&#10;        options.UseInMemoryDatabase(&quot;TestingDb&quot;));&#10;}&#10;else&#10;{&#10;    builder.Services.AddDbContext&lt;EcommerceDbContext&gt;(options =&gt;&#10;        options.UseNpgsql(builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));&#10;}&#10;&#10;// Register services&#10;builder.Services.AddScoped&lt;ProductService&gt;();&#10;&#10;var app = builder.Build();&#10;&#10;// Configure the HTTP request pipeline.&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.MapOpenApi();&#10;}&#10;&#10;app.UseSwagger();&#10;app.UseSwaggerUI();&#10;app.UseHttpsRedirection();&#10;app.MapControllers();&#10;&#10;using (var scope = app.Services.CreateScope())&#10;{&#10;    var db = scope.ServiceProvider.GetRequiredService&lt;EcommerceDbContext&gt;();&#10;    // Only attempt migrations for relational providers (avoids failures with InMemory during tests)&#10;    if (db.Database.IsRelational())&#10;    {&#10;        db.Database.Migrate();&#10;    }&#10;    // Skip seeding in Testing environment to allow integration tests to control data&#10;    if (!app.Environment.IsEnvironment(&quot;Testing&quot;))&#10;    {&#10;        DbSeeder.Seed(db);&#10;    }&#10;}&#10;&#10;app.Run();&#10;&#10;// Expose Program class for WebApplicationFactory in tests&#10;public partial class Program { }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/fuzfriend.ProductsApi/Services/ProductService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fuzfriend.ProductsApi/Services/ProductService.cs" />
              <option name="originalContent" value="using fuzfriend.ProductsApi.Data;&#10;using fuzfriend.ProductsApi.DTOs;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;namespace fuzfriend.ProductsApi.Services;&#10;&#10;public class ProductService&#10;{&#10;    private readonly EcommerceDbContext _context;&#10;&#10;    public ProductService(EcommerceDbContext context)&#10;    {&#10;        _context = context;&#10;    }&#10;&#10;    public async Task&lt;ProductResponse&gt; GetProductsAsync(ProductQueryDto? query)&#10;    {&#10;        // Ensure a non-null query and sane pagination defaults&#10;        query ??= new ProductQueryDto();&#10;        var page = query.Page &lt;= 0 ? 1 : query.Page;&#10;        var pageSize = query.PageSize &lt;= 0 ? 20 : Math.Min(query.PageSize, 100);&#10;&#10;        var productsQuery = _context.Products.AsQueryable();&#10;&#10;        // Normalize incoming filters: treat empty/zero as not provided&#10;        var category = string.IsNullOrWhiteSpace(query.Category) ? null : query.Category;&#10;        var brands = query.Brands?.Where(b =&gt; !string.IsNullOrWhiteSpace(b)).ToList();&#10;        var colours = query.Colours?.Where(c =&gt; !string.IsNullOrWhiteSpace(c)).ToList();&#10;        var sizes = query.Sizes?.Where(s =&gt; !string.IsNullOrWhiteSpace(s)).ToList();&#10;&#10;        decimal? minPrice = query.MinPrice.HasValue &amp;&amp; query.MinPrice.Value &gt; 0 ? query.MinPrice.Value : null;&#10;        decimal? maxPrice = query.MaxPrice.HasValue &amp;&amp; query.MaxPrice.Value &gt; 0 ? query.MaxPrice.Value : null;&#10;        if (minPrice.HasValue &amp;&amp; maxPrice.HasValue &amp;&amp; maxPrice &lt; minPrice)&#10;        {&#10;            // swap to avoid excluding all results due to inverted bounds&#10;            (minPrice, maxPrice) = (maxPrice, minPrice);&#10;        }&#10;&#10;        double? minRating = query.MinRating.HasValue &amp;&amp; query.MinRating.Value &gt; 0 ? query.MinRating.Value : null;&#10;        bool? onPromotion = query.OnPromotion; // keep explicit bool, no special normalization&#10;&#10;        // Determine if any filters were provided using normalized values&#10;        var noFilters = category == null&#10;                        &amp;&amp; (brands == null || brands.Count == 0)&#10;                        &amp;&amp; (colours == null || colours.Count == 0)&#10;                        &amp;&amp; (sizes == null || sizes.Count == 0)&#10;                        &amp;&amp; !minPrice.HasValue&#10;                        &amp;&amp; !maxPrice.HasValue&#10;                        &amp;&amp; !minRating.HasValue&#10;                        &amp;&amp; !onPromotion.HasValue;&#10;&#10;        // Apply filters (only when provided)&#10;        if (!string.IsNullOrEmpty(category))&#10;            productsQuery = productsQuery.Where(p =&gt; p.Category == category);&#10;        if (brands?.Any() == true)&#10;            productsQuery = productsQuery.Where(p =&gt; brands.Contains(p.Brand));&#10;        if (colours?.Any() == true)&#10;            productsQuery = productsQuery.Where(p =&gt; colours.Contains(p.Color));&#10;        if (sizes?.Any() == true)&#10;            productsQuery = productsQuery.Where(p =&gt; sizes.Contains(p.Size));&#10;        if (minPrice.HasValue)&#10;            productsQuery = productsQuery.Where(p =&gt; p.Price &gt;= minPrice.Value);&#10;        if (maxPrice.HasValue)&#10;            productsQuery = productsQuery.Where(p =&gt; p.Price &lt;= maxPrice.Value);&#10;        if (minRating.HasValue)&#10;            productsQuery = productsQuery.Where(p =&gt; p.Rating &gt;= minRating.Value);&#10;        if (onPromotion.HasValue)&#10;            productsQuery = productsQuery.Where(p =&gt; p.OnPromotion == onPromotion.Value);&#10;&#10;        // If no filters were provided, treat as a default &quot;return all products&quot; request&#10;        var effectiveQuery = (noFilters ? _context.Products : productsQuery).AsNoTracking();&#10;&#10;        // Total count + paginated products&#10;        var totalCount = await effectiveQuery.CountAsync();&#10;        var products = await effectiveQuery&#10;            .OrderBy(p =&gt; p.Title)&#10;            .Skip((page - 1) * pageSize)&#10;            .Take(pageSize)&#10;            .ToListAsync();&#10;&#10;        // Available filters based on the current result set&#10;        var filterSource = await effectiveQuery&#10;            .Select(p =&gt; new&#10;            {&#10;                p.Category,&#10;                p.Brand,&#10;                p.Color,&#10;                p.Size,&#10;                p.Price,&#10;                p.Rating,&#10;                p.OnPromotion&#10;            })&#10;            .ToListAsync();&#10;&#10;        var availableFilters = new FilterOptions&#10;        {&#10;            Categories = filterSource.Select(p =&gt; p.Category).Distinct().ToList(),&#10;            Brands = filterSource.Select(p =&gt; p.Brand).Distinct().ToList(),&#10;            Colours = filterSource.Select(p =&gt; p.Color).Distinct().ToList(),&#10;            Sizes = filterSource.Select(p =&gt; p.Size).Distinct().ToList(),&#10;            MinPrice = filterSource.Any() ? filterSource.Min(p =&gt; p.Price) : 0,&#10;            MaxPrice = filterSource.Any() ? filterSource.Max(p =&gt; p.Price) : 0,&#10;            Ratings = filterSource.Select(p =&gt; (int)Math.Floor(p.Rating)).Distinct().OrderBy(r =&gt; r).ToList(),&#10;            HasPromotions = filterSource.Any(p =&gt; p.OnPromotion)&#10;        };&#10;&#10;        return new ProductResponse&#10;        {&#10;            Products = products,&#10;            Filters = availableFilters,&#10;            TotalCount = totalCount&#10;        };&#10;    }&#10;}" />
              <option name="updatedContent" value="using fuzfriend.ProductsApi.Data;&#10;using fuzfriend.ProductsApi.DTOs;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;namespace fuzfriend.ProductsApi.Services;&#10;&#10;public class ProductService&#10;{&#10;    private readonly EcommerceDbContext _context;&#10;&#10;    public ProductService(EcommerceDbContext context)&#10;    {&#10;        _context = context;&#10;    }&#10;&#10;    public async Task&lt;ProductResponse&gt; GetProductsAsync(ProductQueryDto? query)&#10;    {&#10;        // Ensure a non-null query and sane pagination defaults&#10;        query ??= new ProductQueryDto();&#10;        var page = query.Page &lt;= 0 ? 1 : query.Page;&#10;        var pageSize = query.PageSize &lt;= 0 ? 20 : Math.Min(query.PageSize, 100);&#10;&#10;        var productsQuery = _context.Products.AsQueryable();&#10;&#10;        // Normalize incoming filters: treat empty/zero as not provided&#10;        var category = string.IsNullOrWhiteSpace(query.Category) ? null : query.Category;&#10;        var categories = query.Categories?.Where(c =&gt; !string.IsNullOrWhiteSpace(c)).ToList() ?? new List&lt;string&gt;();&#10;        if (category != null)&#10;        {&#10;            categories.Add(category);&#10;        }&#10;        categories = categories.Distinct().ToList();&#10;&#10;        var brands = query.Brands?.Where(b =&gt; !string.IsNullOrWhiteSpace(b)).Distinct().ToList();&#10;        var colours = query.Colours?.Where(c =&gt; !string.IsNullOrWhiteSpace(c)).Distinct().ToList();&#10;        var sizes = query.Sizes?.Where(s =&gt; !string.IsNullOrWhiteSpace(s)).Distinct().ToList();&#10;&#10;        decimal? minPrice = query.MinPrice.HasValue &amp;&amp; query.MinPrice.Value &gt; 0 ? query.MinPrice.Value : null;&#10;        decimal? maxPrice = query.MaxPrice.HasValue &amp;&amp; query.MaxPrice.Value &gt; 0 ? query.MaxPrice.Value : null;&#10;        if (minPrice.HasValue &amp;&amp; maxPrice.HasValue &amp;&amp; maxPrice &lt; minPrice)&#10;        {&#10;            // swap to avoid excluding all results due to inverted bounds&#10;            (minPrice, maxPrice) = (maxPrice, minPrice);&#10;        }&#10;&#10;        double? minRating = query.MinRating.HasValue &amp;&amp; query.MinRating.Value &gt; 0 ? query.MinRating.Value : null;&#10;        bool? onPromotion = query.OnPromotion; // keep explicit bool, no special normalization&#10;&#10;        // Determine if any filters were provided using normalized values&#10;        var noFilters = (categories == null || categories.Count == 0)&#10;                        &amp;&amp; (brands == null || brands.Count == 0)&#10;                        &amp;&amp; (colours == null || colours.Count == 0)&#10;                        &amp;&amp; (sizes == null || sizes.Count == 0)&#10;                        &amp;&amp; !minPrice.HasValue&#10;                        &amp;&amp; !maxPrice.HasValue&#10;                        &amp;&amp; !minRating.HasValue&#10;                        &amp;&amp; !onPromotion.HasValue;&#10;&#10;        // Apply filters (only when provided)&#10;        if (categories?.Any() == true)&#10;            productsQuery = productsQuery.Where(p =&gt; categories.Contains(p.Category));&#10;        if (brands?.Any() == true)&#10;            productsQuery = productsQuery.Where(p =&gt; brands.Contains(p.Brand));&#10;        if (colours?.Any() == true)&#10;            productsQuery = productsQuery.Where(p =&gt; colours.Contains(p.Color));&#10;        if (sizes?.Any() == true)&#10;            productsQuery = productsQuery.Where(p =&gt; sizes.Contains(p.Size));&#10;        if (minPrice.HasValue)&#10;            productsQuery = productsQuery.Where(p =&gt; p.Price &gt;= minPrice.Value);&#10;        if (maxPrice.HasValue)&#10;            productsQuery = productsQuery.Where(p =&gt; p.Price &lt;= maxPrice.Value);&#10;        if (minRating.HasValue)&#10;            productsQuery = productsQuery.Where(p =&gt; p.Rating &gt;= minRating.Value);&#10;        if (onPromotion.HasValue)&#10;            productsQuery = productsQuery.Where(p =&gt; p.OnPromotion == onPromotion.Value);&#10;&#10;        // If no filters were provided, treat as a default &quot;return all products&quot; request&#10;        var baseQuery = (noFilters ? _context.Products : productsQuery).AsNoTracking();&#10;&#10;        // Sorting&#10;        var sortBy = (query.SortBy ?? &quot;title&quot;).Trim().ToLowerInvariant();&#10;        var sortDir = (query.SortDirection ?? &quot;asc&quot;).Trim().ToLowerInvariant();&#10;        bool desc = sortDir == &quot;desc&quot; || sortDir == &quot;descending&quot;;&#10;&#10;        IOrderedQueryable&lt;Models.Product&gt; ordered = sortBy switch&#10;        {&#10;            &quot;price&quot; =&gt; desc ? baseQuery.OrderByDescending(p =&gt; p.Price) : baseQuery.OrderBy(p =&gt; p.Price),&#10;            &quot;rating&quot; =&gt; desc ? baseQuery.OrderByDescending(p =&gt; p.Rating) : baseQuery.OrderBy(p =&gt; p.Rating),&#10;            &quot;brand&quot; =&gt; desc ? baseQuery.OrderByDescending(p =&gt; p.Brand) : baseQuery.OrderBy(p =&gt; p.Brand),&#10;            &quot;category&quot; =&gt; desc ? baseQuery.OrderByDescending(p =&gt; p.Category) : baseQuery.OrderBy(p =&gt; p.Category),&#10;            _ =&gt; desc ? baseQuery.OrderByDescending(p =&gt; p.Title) : baseQuery.OrderBy(p =&gt; p.Title)&#10;        };&#10;&#10;        // Total count + paginated products&#10;        var totalCount = await baseQuery.CountAsync();&#10;        var products = await ordered&#10;            .Skip((page - 1) * pageSize)&#10;            .Take(pageSize)&#10;            .ToListAsync();&#10;&#10;        // Available filters based on the current result set&#10;        var filterSource = await baseQuery&#10;            .Select(p =&gt; new&#10;            {&#10;                p.Category,&#10;                p.Brand,&#10;                p.Color,&#10;                p.Size,&#10;                p.Price,&#10;                p.Rating,&#10;                p.OnPromotion&#10;            })&#10;            .ToListAsync();&#10;&#10;        var availableFilters = new FilterOptions&#10;        {&#10;            Categories = filterSource.Select(p =&gt; p.Category).Distinct().ToList(),&#10;            Brands = filterSource.Select(p =&gt; p.Brand).Distinct().ToList(),&#10;            Colours = filterSource.Select(p =&gt; p.Color).Distinct().ToList(),&#10;            Sizes = filterSource.Select(p =&gt; p.Size).Distinct().ToList(),&#10;            MinPrice = filterSource.Any() ? filterSource.Min(p =&gt; p.Price) : 0,&#10;            MaxPrice = filterSource.Any() ? filterSource.Max(p =&gt; p.Price) : 0,&#10;            Ratings = filterSource.Select(p =&gt; (int)Math.Floor(p.Rating)).Distinct().OrderBy(r =&gt; r).ToList(),&#10;            HasPromotions = filterSource.Any(p =&gt; p.OnPromotion)&#10;        };&#10;&#10;        return new ProductResponse&#10;        {&#10;            Products = products,&#10;            Filters = availableFilters,&#10;            TotalCount = totalCount&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>